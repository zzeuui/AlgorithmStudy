# 그래프의 깊이 우선 탐색(Depth-First Search, DFS)

- 현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 가는 간선을 선택하여 계속 탐색 진행. 막힌 정점에 도달하면 이전 경로로 돌아감
```
int adj = [[]] #인접 리스트 표현
bool visited = [false]*len(adj) #정점의 방문 여부

def dfs(int here):
  visited[here] = true
  
  for i in adj[here]:
    if not visited[i]:
      dfs(i)

def dfsAll():
  for i in range(len(adj)):
    if not visited[i]:
      dfs(i)
```

- 시간 복잡도
   - 인접 리스트: $O(|V|+|E|)$
   - 인접 행렬: $O(|V|^{2})$

- 간단한 예제
   1. 두 정점의 연결 여부  
     dfs(u) 수행 후 visited 참조 $\Rightarrow$ u로부터 각 정점에 갈 수 있는지 확인 가능
   2. 그래프 내의 연결된 부분집합의 개수  
     dfsAll()에서 dfs()를 호출한 횟수
   3. 위상 정렬(topological sort)  
     dfsAll()의 내부의 dsf()가 종료할 때마다 현재 정점 번호 기록후, dsfAll()이 종료하면 기록된 순서를 뒤집기

### 오일러 서킷과 트레일, 해밀토니안 경로
1. 오일러 서킷(Euler circuit)
   - 그래프의 모든 간선을 한 번씩 지나서 시작점으로 돌아오는 경로
   - 모든 정점들이 짝수점일 경우 존재함, *들어오는 간선 수와 나가는 간선 수가 일치해야함
     - 한 정점의 인접한 간선의 수를 해당 정점의 차수(degree)라고 부르고, 차수가 홀수면 홀수점이고 짝수면 짝수점이라고함
   - 이미 지난 간선 정보는 삭제되도록 코드 구현

2. 오일러 트레일(Euler circuit)
   - 그래프의 모든 간선을 한 번씩 지나면서 시작점과 끝점이 다른 경로
   - 시작점의 경우 들어오는 간선 수가 하나 적어야 하고, 끝점의 경우 나가는 간선 수가 하나 적어야 함. 즉, 시작점과 끝점에 하나의 간선을 추가했을 때 그래프의 모든 정점이 짝수점이 되어야함.

3. 해밀토니안 경로(Hamiltonian path)
   - 그래프의 모든 정점을 한 번씩 지나는 경로
   
### 그래프 간선의 분류
- 깊이 우선 탐색을 하면, 그래프의 정점들과 DFS가 따라가는 간선들로 구성된 트리가 만들어짐. 이러한 트리를 *깊이 우선 탐색 스패닝 트리* 혹은 
*DFS spanning tree*라고 함
- 그래프 간선의 분류
   - 트리 간선(tree edge): 스패닝 트리에 포함된 간선
   - 순방향 간선(forword edge): 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선
   - 역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되지만 트리 간선이 아닌 간선
   - 교차 간선(cross edge): 스패닝 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 트리 간선이 아닌 간선
 
- 무향 그래프 간선의 분류
   - 모든 간선이 양방향으로 통행 가능
   - 교차 간선이 존재하지 않음
   - 순방향 간선과 역방향 간선의 구분이 없음

- 그래프 알고리즘의 이해
   - (u, v)가 트리 간선이라면 dfs(v)가 dfs(u)보다 먼저 종료되어야함
   - (u, v)가 순방향 간선이라면 v가 u의 자손임으로 dfs(u)가 먼저 호출되고, dfs(v)가 먼저 종료되어야함
   - (u, v)가 역방향 간선이라면 v가 u의 선조임으로 dfs(v)가 먼저 호출되고, dfs(u)가 먼저 종료되어야함
   - (u, v)가 교차 간선이라면 dfs(v)가 호출·종료되고나서 dfs(u)가 호출되어야함. 
   - 역방향 간선이 존재하면, 사이클이 존재함  
     $\Rightarrow$ DFS 과정에서 제일 처음 만나는 사이클의 한 정점이 u이고 u가 v로 향한다고 했을 때, dfs(u)가 종료되기 전에 dfs(v)에 의해 u를 다시 방문하게 되면 (u, v)는 역방향 간선이고 사이클이 존재함을 의미함.

- 간선의 분류 구현
   - 단순히 정점을 방문했다는 정보(visited)가 아니라, 배열읈 사용해 해당 정점을 발견한 순서에 대한 정보(discovered)를 저장함.
   
     
