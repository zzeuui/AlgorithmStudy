### 문제
최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다. 카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다. 그들은 M과 N보다 작거나 같은 두 개의 자연수 x, y를 가지고 각 년도를 <x:y>와 같은 형식으로 표현하였다. 그들은 이 세상의 시초에 해당하는 첫 번째 해를 <1:1>로 표현하고, 두 번째 해를 <2:2>로 표현하였다. <x:y>의 다음 해를 표현한 것을 <x':y'>이라고 하자. 만일 x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다. 같은 방식으로 만일 y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다. <M:N>은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다.

예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 <1:1>로 표현되고, 11번째 해는 <1:11>로 표현된다. <3:1>은 13번째 해를 나타내고, <10:12>는 마지막인 60번째 해를 나타낸다.

네 개의 정수 M, N, x와 y가 주어질 때, <M:N>이 카잉 달력의 마지막 해라고 하면 <x:y>는 몇 번째 해를 나타내는지 구하는 프로그램을 작성하라.

### 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 한 줄로 구성된다. 각 줄에는 네 개의 정수 M, N, x와 y가 주어진다. (1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N) 여기서 <M:N>은 카잉 달력의 마지막 해를 나타낸다.

### 출력
출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 여기서 k는 <x:y>가 k번째 해를 나타내는 것을 의미한다. 만일 <x:y>에 의해 표현되는 해가 없다면, 즉, <x:y>가 유효하지 않은 표현이면, -1을 출력한다.

### 풀이
##### 1. 첫번째 조건  
<m:->이 마지막 해이고 <x:->일 때, 다음 연도들이 정답 후보가 될 수 있음
> x+m\*0, x+m\*1, x+m\*2, x+m*3, ...

<-:n>이 마지막 해이고 <-:y>일 때, 다음 연도들이 정답 후보가 될 수 있음
> y+n\*0, y+n\*1, y+n\*2, y+n\*3, ...

<m:n>이 마지막 해이고 <x:y>일 때, 해당 연도는 x+m\*i와 y+n\*j가 동일한 해임  
그러므로 k가 해당 연도라면, x+m\*i = k와 y+n\*j = k를 만족하는 해를 찾으면 됨  
수식을 다시 정리하면 k-x = m\*i, k-y = n\*j 인데,  
이 수식의 의미는 k-x가 m의 배수이고, k-y가 n의 배수임을 만족하면 되는 것이고,  
k를 찾기위한 조건을 다음과 같이 다시 설정할 수 있음  
(k-x)%m == 0 and (k-y)%n == 0  

##### 2. 두번째 조건
또한 마지막 해 <m:n>은 m과 n의 최소 공배수임.  
이때 최소 공배수는 두 수의 곱일 수도 있으므로 탐색 범위는 k <= m*n으로 설정함.  

```
import sys
input = sys.stdin.readline

def count_year(m,n,x,y):

    k = x
    while m*n >= k: #두번째 조건
        if (k-x)%m == 0 and (k-y)%n == 0: #첫번째 조건
            return k

        k += m

    return -1

if __name__=='__main__':
    for _ in range(int(input())):
        m, n, x, y = map(int, input().rstrip().split())
        print(count_year(m,n,x,y))
```
