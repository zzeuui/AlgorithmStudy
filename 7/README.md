# 07 분할정복
분할정복
- 부분 문제의 답으로부터 전체 문제의 답을 계산함
- 부분 문제들의 크기가 비슷하여, 일반적인 재귀호출과 다름

분할정복 과정
- divide: 문제를 더 작은 문제로 분할하는 과정
- merge: 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정
- base case: 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

## quadtree.py
문제정의
- 이미지가 네 부분으로 나누어지고, 만일 한 부분의 전체가 흰색이면 w, 검정이면 b로 압축됨. 같은색이아니라면 x 꼬리표가 붙고 다시 네 부분으로 나누어짐
- 위와 같은 논리로 만들어진 이미지를 압축한 쿼드트리가 주어졌을 때, 압축을 풀고 이미지를 뒤집어 다시 쿼드트리를 구해야함.

알고리즘
- 분할정복과 재귀호출을 사용하지 않음
- 입력을 리스트로 만든 뒤, 뒤에서부터 차례로 검사해 'x'를 만나면 이전의 4개의 원소에 대해 뒤집기를 시전하고 하나의 문자열로 만들어 리스트의 그 자리에 삽입함.

비고
- 처음에는 재귀호출로 구현했으나 풀이를 읽고 나서 굳이 재귀호출을 하지않고 'x'를 찾아 1D 리스트로 구성된 입력을 트리처럼 바꾸는 과정에서 바로 적용해도 괜찮다고 생각함.

## fence.py
문제정의
- 높이가 모두 다른 울타리가 주어졌을 때, 연속된 울타리 중 가장 크기가 큰 경우에 대해 구함.
- 높이가 모두 다르기 때문에, 연속된 울타리의 크기는 (울타리수X울타리중가장작은높이)임.

알고리즘
- 분할정복과 재귀호출
  - 울타리의 왼쪽, 오른쪽, 중앙으로 나누어 연속된 울타리의 크기를 구함출
  - 울타리의 크기를 구할 때, 재귀호출을 이용
  ```
  def compute(self, high):
        ...
        
        left_sq = self.compute(high[left:mid])
        right_sq = self.compute(high[mid:right])
        
        ...
        
        mid_est = len(high[l:r])*min(high[l:r])
        self.highest = max(self.highest, mid_est)

        while l-1 >= left and r+1 < right:
            if high[l-1] > high[r+1]:
                l -= 1
            else:
                r += 1

            mid_est = len(high[l:r])*min(high[l:r])
            self.highest = max(self.highest, mid_est)
        
        ...
        
        self.highest = max(self.highest, left_sq, right_sq)

        return len(high)*min(high)
  ```
- 기저사례설정
  - 분할하다가 하나의 울타리만 남았을 때 반환
  ```
  def compute(self, high):
      if len(high) == 1:
         return high[0]
  ```
비고
- 책 풀이를 완전히 참고함 

## fanmeeting.py
문제정의
- 멤버와 팬이 있을 때, 팬들이 가장 오른쪽 멤버부터 시작해 한 명씩 왼쪽으로 움직이며 포옹을 함.
- 멤버와 팬은 여자와 남자로 구분할 수 있고, 남자멤버는 남자팬과 포옹하지 않음.
- 위의 상황일 때 모든 멤버가 동시에 포옹하는 횟수를 구함.

알고리즘
- 분할정복과 재귀호출을 사용하지 않음
- 파이썬에서는 길이가 같은 리스트를 묶어 병렬로 for문을 실행할 수 있는 zip() 함수를 제공함
- zip() 함수를 사용해, 모든 경우의 수를 탐색하지만 빠르게 실행함
